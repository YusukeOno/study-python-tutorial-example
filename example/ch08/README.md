# Introduction

* 継承と合成の併用
* オブジェクトの型の検査
* 抽象規定クラスを用いた「インターフェイス」の記述

## 階層構造の問題点

オブジェクト指向には、分離、カプセル化、情報とビヘイビアーの分類といった概念が登場する。公開されているライブラリの中には、物と物との関係を記述するのに、完全に独自の方法で記述し分類しているものもある。単純に階層構造を作るのはうまくいくこともあるが、ソフトウェアのビヘイビアーが関連すると問題が発生する。ソフトウェアの成長に伴って、クラス間の親子関係を素直に保つのが難しくなってくる。

なぜ、まだ継承が使われているのだろうか。

## 継承は本当は何のためのものか

しかしいまだに警鐘を使うべきではないところで使っている。継承はビヘイビアーの特化に使うべきものだ。別の言い方をすると、コードの再利用のためだけにサブクラスを使うのは間違いだ。メソッドが異なる値を返すようにするために、あるいは異なるビヘイビアーをするためにサブクラスを作成するべきだ。

このような意味で、サブクラスはスーパークラスの「特殊ケース」として扱われるべきなのだ。スーパークラスのコードを再利用することにはなるが、「サブクラスのインスタンスはスーパークラスのインスタンスである」というアイデアの自然な結果としてのみ使うようにするべきなのだ。

クラスBがクラスAを継承する場合、BはAである（B is an A）という。このとき、Bのインスタンスは実際にAのインスタンスであり、実際にAのように見えなければならない。これに対して、クラスCのインスタンスがクラスDのインスタンスを利用する場合、CはDをもつ（C has a D）という。これはCはDを構成要素として含むということを強調している。

## 置換可能性

Barbara Liskovは、継承と関連して「置換可能性」という概念を提起した。プログラミングの正しさに影響することなく、あるクラスのインスタンスを、そのサブクラスのインスタンスと置換（交換）できなければならないという概念だ。ここでいう「正しさ」とは、プログラムにエラーがなく、具体的な結果は違ってしまうかもしれないが、基本的には同じような出力が得られるという意味である。置換可能性は、サブクラスがスーパークラスのインターフェイスを厳密に守っていないと実現できない。

## 継承が使える理想的なケース

Sandi Metzは、いつ警鐘を使うべきかに関する次のような基本ルールを提案している。

1. 解こうとしてる問題が、浅く狭い階層構造を持っている
2. サブクラスはオブジェクトグラフの葉にある（他のオブジェクトを利用していない）
3. サブクラスはスーパークラスのすべてのビヘイビアーを利用する（あるいは特化している）

### 浅く狭い階層構造

クラスの階層が深いと管理が困難になり、バグの混入を招きがちになる。階層を浅く抑え気味に保つことで、さまざまな判断が容易になる。

階層が浅いとは、サブクラスが多すぎるクラスが階層にないことを意味する。サブクラスの数が増えるにつれて、どのサブクラスがどの特殊かを担当するのかが分かりにくくなる。また、「自分が望むものがない」という理由で他の開発者がサブクラスをコピーして新しいものを作ってしまうかもしれない。

### オブジェクトグラフの末端のサブクラス

プログラム内のすべてのオブジェクトを、継承あるいは合成を介して接続されているグラフのノードと考えることができる。警鐘を利用すると、1つのクラスが他のオブジェクトと接続されていることになるが、そのクラスのサブクラスは一般にはそれ以上の依存性を持つべきではない。サブクラスはビヘイビアーの特殊化のためのものである。あるサブクラスが（スーパークラスもしくは他のサブクラスが持たない）ユニークな依存性を持っている場合は、合成の方が適している可能性が高い。

### サブクラスとスーパークラスのビヘイビアーの関係

サブクラスが、is-aの関係を持つ場合、サブクラスはスーパークラスのすべてのビヘイビアーを利用することになる。サブクラスがスーパークラスのすべてのビヘイビアーを使わないのなら、本当にスーパークラスのインスタンスであると言えるだろうか。

# Conclusion

* 継承を利用するのは、「真のis-a（〜である）関係」を表現するときだけにする（ビヘイビアーの特化に使う）
* 合成はhas-a関係がある時に用いる（コードの再利用に有効）
* 多重継承の際のメソッド参照は、メソッド解決順序によって決まる
* Pythonにおいては抽象基底クラスを使うことで、他のプログラミング言語の「インターフェイス」のような機能の利用できる
